<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>è²ªåƒè›‡éŠæˆ²</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* --- CSS å…§å®¹é–‹å§‹ (åŒ…å«æ‰‹æ©Ÿæ ¼å¼èª¿æ•´èˆ‡æ–¹å‘éµ) --- */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f4f4f4;
            touch-action: none; 
        }

        .screen {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            display: none; 
            width: 90%; 
            max-width: 460px; /* é™åˆ¶æœ€å¤§å¯¬åº¦ */
        }

        .screen.active {
            display: block; 
        }
        
        /* éŠæˆ²ç•«å¸ƒå®¹å™¨ */
        #gameContainer {
            position: relative;
            width: 400px; 
            height: 400px; 
            margin: 0 auto 15px; /* ä¸‹æ–¹ç•™å‡ºç©ºé–“çµ¦æ–¹å‘éµ */
        }
        
        /* éŸ¿æ‡‰å¼èª¿æ•´ï¼šç¢ºä¿å®¹å™¨åœ¨å°è¢å¹•ä¸Šå¯ä»¥ç¸®æ”¾ */
        @media screen and (max-width: 480px) {
            #gameContainer {
                width: calc(100vw - 40px); 
                height: calc(100vw - 40px); 
                max-width: 400px;
                max-height: 400px;
            }
        }

        #gameCanvas {
            border: 5px solid #333;
            background-color: #eee;
            display: block;
        }

        #infoBar {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            font-weight: bold;
            font-size: 0.9em; 
        }
        
        /* --- æ–¹å‘éµ (D-Pad) æ¨£å¼ --- */
        #dpad-container {
            display: grid;
            /* ä½¿ç”¨ Grid å‰µå»º 3x3 ä½ˆå±€ï¼Œä¸­é–“ç‚ºç©º */
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 150px; /* æ§åˆ¶ D-Pad ç¸½å¯¬åº¦ */
            height: 150px; /* æ§åˆ¶ D-Pad ç¸½é«˜åº¦ */
            margin: 15px auto 0;
            user-select: none; /* é˜²æ­¢é¸ä¸­æ–‡å­— */
            -webkit-user-select: none; /* å…¼å®¹ Safari */
        }

        .dpad-button {
            background-color: #616161;
            color: white;
            border: none;
            padding: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: background-color 0.1s;
        }

        .dpad-button:active {
            background-color: #333;
        }

        /* ä½ˆå±€å®šä½ */
        #dpad-up {
            grid-column: 2 / 3;
            grid-row: 1 / 2;
        }
        #dpad-left {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
        }
        #dpad-right {
            grid-column: 3 / 4;
            grid-row: 2 / 3;
        }
        #dpad-down {
            grid-column: 2 / 3;
            grid-row: 3 / 4;
        }
        /* è®“ä¸­é–“ç©ºä¸€æ ¼ */
        .dpad-center-filler {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
        }

        /* å…¶ä»–é€šç”¨æ¨£å¼ä¿æŒä¸è®Š */
        button {
            padding: 10px 15px; 
            margin: 8px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }

        #currentScoreRecord {
            margin-top: 15px;
            padding: 10px;
            border: 1px dashed #333;
            background-color: #ffe0b2; 
            font-weight: bold;
            display: none; 
        }
        
        #touchOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background-color: transparent; 
            cursor: pointer;
        }
        /* --- CSS å…§å®¹çµæŸ --- */
    </style>
</head>
<body>

    <div id="startScreen" class="screen active">
        <h1>è²ªåƒè›‡éŠæˆ² ğŸ</h1>
        <p class="developer-info">å¸ƒæ´›å…‹åœ‹ç‹é–‹ç™¼</p>
        <label for="playerName">è«‹è¼¸å…¥éŠç©åç¨±ï¼š</label>
        <input type="text" id="playerName" placeholder="ç©å®¶åç¨±" required autocomplete="off">
        
        <br><br>

        <label for="difficulty">é¸æ“‡é›£åº¦ï¼š</label>
        <select id="difficulty">
            <option value="easy">æ˜“ (ç„¡éšœç¤™, æ…¢)</option>
            <option value="medium" selected>ä¸­ (å°‘é‡ç‰†, æ¨™æº–)</option>
            <option value="hard">é›£ (æ›´å¤šç‰†, å¿«)</option>
            <option value="extreme">æ¥µé›£ (æ¥µå¿«)</option>
        </select>

        <br><br>
        
        <button id="startGameButton">é–‹å§‹éŠæˆ²</button>
        
        <div id="currentScoreRecord">
            **ä¸Šå±€æˆç¸¾**ï¼š
            <span id="recordedScore">0</span> åˆ†
        </div>
    </div>

    <div id="gameScreen" class="screen">
        <div id="infoBar">
            <span>ç©å®¶ï¼š<span id="displayPlayerName"></span></span>
            <span>é›£åº¦ï¼š<span id="displayDifficulty"></span></span>
            <span>åˆ†æ•¸ï¼š<span id="score">0</span></span>
        </div>
        
        <div id="gameContainer">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            <div id="touchOverlay"></div>
        </div>
        
        <div id="dpad-container">
            <button class="dpad-button" id="dpad-up">â–²</button>
            <div class="dpad-center-filler"></div>
            <button class="dpad-button" id="dpad-left">â—€</button>
            <button class="dpad-button" id="dpad-right">â–¶</button>
            <button class="dpad-button" id="dpad-down">â–¼</button>
        </div>
    </div>

    <div id="gameOverScreen" class="screen">
        <h2 id="gameOverMessage">è²ªåƒè›‡éŠæˆ² - çµæŸï¼</h2>
        <p>ä½ çš„åˆ†æ•¸æ˜¯ï¼š<span id="finalScore">0</span></p>
        <button id="reviveButton">å¾©æ´»</button>
        <button id="restartButton">å›åˆ°é¦–é </button> 
        <p>è‹¥æ²’æœ‰å¾©æ´»ï¼Œ<span id="countdown">5</span> ç§’å¾Œè‡ªå‹•å›åˆ°é¦–é ...</p>
    </div>

    <script>
        // --- JavaScript å…§å®¹é–‹å§‹ (ä¿®æ­£å¾©æ´»å¾Œåœ°å½¢å•é¡Œ) ---

        // --- å…ƒç´ é¸æ“‡å™¨ ---
        const startScreen = document.getElementById('startScreen');
        const gameScreen = document.getElementById('gameScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startGameButton = document.getElementById('startGameButton');
        const reviveButton = document.getElementById('reviveButton');
        const restartButton = document.getElementById('restartButton');
        const playerNameInput = document.getElementById('playerName');
        const difficultySelect = document.getElementById('difficulty');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const finalScoreDisplay = document.getElementById('finalScore');
        const countdownDisplay = document.getElementById('countdown');
        const recordedScoreDisplay = document.getElementById('recordedScore');
        const scoreRecordContainer = document.getElementById('currentScoreRecord');
        const gameContainer = document.getElementById('gameContainer');
        const touchOverlay = document.getElementById('touchOverlay'); 
        
        // D-Pad å…ƒç´ 
        const dpadUp = document.getElementById('dpad-up');
        const dpadDown = document.getElementById('dpad-down');
        const dpadLeft = document.getElementById('dpad-left');
        const dpadRight = document.getElementById('dpad-right');


        // --- éŠæˆ²è¨­å®šè®Šæ•¸ ---
        let playerName = '';
        let currentDifficulty = 'medium';
        let gameSpeed = 150; 
        const INITIAL_TILE_COUNT = 20; 
        const INITIAL_CANVAS_SIZE = 400; 
        let snake = [];
        let foods = []; 
        let obstacles = []; 
        let direction = { x: 1, y: 0 }; 
        let score = 0;
        let gameIntervalId;
        let countdownIntervalId;
        let isMoving = false; 

        // --- é›£åº¦è¨­å®š ---
        const difficultySettings = {
            easy: { speed: 180, label: 'æ˜“ (æ…¢)', obstacleCount: 0, maxFoods: 5 },        
            medium: { speed: 130, label: 'ä¸­ (æ¨™æº–)', obstacleCount: 8, maxFoods: 3 },     
            hard: { speed: 80, label: 'é›£ (å¿«)', obstacleCount: 16, maxFoods: 1 },        
            extreme: { speed: 50, label: 'æ¥µé›£ (æ¥µå¿«)', obstacleCount: 20, maxFoods: 1 }  
        };

        const SESSION_SCORE_KEY = 'SNAKE_CURRENT_SCORE';

        // --- éŸ¿æ‡‰å¼èª¿æ•´ Canvas å°ºå¯¸ ---
        function adjustCanvasSize() {
            if (gameScreen.classList.contains('active')) {
                const containerWidth = gameContainer.offsetWidth;
                const newTileSize = Math.floor(containerWidth / INITIAL_TILE_COUNT);
                const newCanvasSize = newTileSize * INITIAL_TILE_COUNT;

                if (newCanvasSize > 0) {
                    canvas.width = newCanvasSize;
                    canvas.height = newCanvasSize;
                    gameContainer.style.width = newCanvasSize + 'px';
                    gameContainer.style.height = newCanvasSize + 'px';
                    if (gameIntervalId) draw(); 
                }
            }
        }
        window.addEventListener('resize', adjustCanvasSize);

        // --- ç•«é¢åˆ‡æ›å‡½æ•¸ ---
        function showScreen(screen) {
            [startScreen, gameScreen, gameOverScreen].forEach(s => {
                s.classList.remove('active');
            });
            screen.classList.add('active');
            
            if (screen === startScreen) {
                loadSessionScore();
                // æ¢å¾©åˆå§‹ Canvas å°ºå¯¸
                canvas.width = INITIAL_CANVAS_SIZE;
                canvas.height = INITIAL_CANVAS_SIZE;
                gameContainer.style.width = INITIAL_CANVAS_SIZE + 'px';
                gameContainer.style.height = INITIAL_CANVAS_SIZE + 'px';
            } else if (screen === gameScreen) {
                adjustCanvasSize(); // é€²å…¥éŠæˆ²æ™‚èª¿æ•´å°ºå¯¸
            } else {
                scoreRecordContainer.style.display = 'none';
            }
        }

        // --- è®€å–/å„²å­˜æœ¬å±€æˆç¸¾ ---
        function loadSessionScore() {
            const lastScore = sessionStorage.getItem(SESSION_SCORE_KEY);
            if (lastScore && !isNaN(parseInt(lastScore))) {
                recordedScoreDisplay.textContent = parseInt(lastScore);
                scoreRecordContainer.style.display = 'block';
            } else {
                scoreRecordContainer.style.display = 'none';
            }
        }
        function saveSessionScore(currentScore) {
            sessionStorage.setItem(SESSION_SCORE_KEY, currentScore.toString());
        }

        // --- æª¢æŸ¥ä½ç½®æ˜¯å¦è¢«ä½”ç”¨ ---
        function isPositionOccupied(x, y) {
            if (snake.some(segment => segment.x === x && segment.y === y)) return true;
            if (obstacles.some(obs => obs.x === x && obs.y === y)) return true;
            if (foods.some(f => f.x === x && f.y === y)) return true;
            return false;
        }

        // --- éšœç¤™ç‰©ç”Ÿæˆå‡½æ•¸ ---
        function generateObstacles() {
            obstacles = [];
            const count = difficultySettings[currentDifficulty].obstacleCount;
            const boundaryX = INITIAL_TILE_COUNT;
            const boundaryY = INITIAL_TILE_COUNT;

            for (let i = 0; i < count; i++) {
                let newObstacle;
                let attempts = 0;
                
                do {
                    newObstacle = {
                        x: Math.floor(Math.random() * boundaryX),
                        y: Math.floor(Math.random() * boundaryY)
                    };
                    attempts++;
                } while (isPositionOccupied(newObstacle.x, newObstacle.y) && attempts < 100); 
                
                if (attempts < 100) {
                    obstacles.push(newObstacle);
                }
            }
        }

        // --- é£Ÿç‰©ç”Ÿæˆå‡½æ•¸ ---
        function generateFoods() {
            const maxFoods = difficultySettings[currentDifficulty].maxFoods;
            const boundaryX = INITIAL_TILE_COUNT;
            const boundaryY = INITIAL_TILE_COUNT;

            while (foods.length < maxFoods) {
                let newFood;
                let attempts = 0;

                do {
                    newFood = {
                        x: Math.floor(Math.random() * boundaryX),
                        y: Math.floor(Math.random() * boundaryY)
                    };
                    attempts++;
                } while (isPositionOccupied(newFood.x, newFood.y) && attempts < 100); 
                
                if (attempts < 100) {
                    foods.push(newFood);
                }
            }
        }

        // --- éŠæˆ²åˆå§‹åŒ–å‡½æ•¸ ---
        function initializeGame() {
            gameSpeed = difficultySettings[currentDifficulty].speed;
            
            snake = [
                { x: 3, y: 1 },
                { x: 2, y: 1 },
                { x: 1, y: 1 }
            ];
            direction = { x: 1, y: 0 }; 
            score = 0;
            foods = []; 
            scoreDisplay.textContent = score;
            isMoving = false; 
            
            ctx.fillStyle = '#eee';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            generateObstacles(); // ç”Ÿæˆæ–°çš„éšœç¤™ç‰©
            generateFoods(); 
            draw();
        }

        // --- ç¹ªè£½å‡½æ•¸ ---
        function draw() {
            const currentTileSize = canvas.width / INITIAL_TILE_COUNT; 
            ctx.fillStyle = '#eee';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'red';
            foods.forEach(food => {
                ctx.fillRect(food.x * currentTileSize, food.y * currentTileSize, currentTileSize, currentTileSize);
            });
            ctx.fillStyle = '#666'; 
            obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x * currentTileSize, obstacle.y * currentTileSize, currentTileSize, currentTileSize);
            });
            snake.forEach((segment, index) => {
                ctx.fillStyle = (index === 0) ? '#006400' : 'black'; 
                ctx.fillRect(segment.x * currentTileSize, segment.y * currentTileSize, currentTileSize, currentTileSize);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(segment.x * currentTileSize, segment.y * currentTileSize, currentTileSize, currentTileSize);
            });
        }

        // --- éŠæˆ²é‚è¼¯ä¸»å¾ªç’° ---
        function updateGame() {
            isMoving = true; 
            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
            const boundaryX = INITIAL_TILE_COUNT;
            const boundaryY = INITIAL_TILE_COUNT;

            const hitWall = head.x < 0 || head.x >= boundaryX || head.y < 0 || head.y >= boundaryY;
            const hitObstacle = obstacles.some(obs => obs.x === head.x && obs.y === head.y);

            if (hitWall || hitObstacle) {
                clearInterval(gameIntervalId);
                saveSessionScore(score); 
                showGameOver(hitWall ? 'ä½ æ’åˆ°ç‰†äº†ï¼' : 'ä½ æ’åˆ°éšœç¤™ç‰©äº†ï¼');
                return; 
            }

            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    clearInterval(gameIntervalId);
                    saveSessionScore(score); 
                    showGameOver('ä½ å’¬åˆ°è‡ªå·±äº†ï¼'); 
                    return;
                }
            }

            snake.unshift(head); 
            let eaten = false;
            const foodIndex = foods.findIndex(f => f.x === head.x && f.y === head.y);

            if (foodIndex !== -1) {
                score += 10;
                scoreDisplay.textContent = score;
                foods.splice(foodIndex, 1); 
                generateFoods(); 
                eaten = true;
            } 

            if (!eaten) {
                snake.pop(); 
            }

            draw();
            isMoving = false; 
        }

        function startGame() {
            playerName = playerNameInput.value || 'åŒ¿åç©å®¶'; 
            currentDifficulty = difficultySelect.value;
            document.getElementById('displayPlayerName').textContent = playerName;
            document.getElementById('displayDifficulty').textContent = difficultySettings[currentDifficulty].label;
            if (gameIntervalId) clearInterval(gameIntervalId);
            initializeGame();
            showScreen(gameScreen);
            gameIntervalId = setInterval(updateGame, gameSpeed);
        }

        function showGameOver(message) {
            if (gameIntervalId) clearInterval(gameIntervalId);
            if (countdownIntervalId) clearInterval(countdownIntervalId);
            document.getElementById('gameOverMessage').textContent = `è²ªåƒè›‡éŠæˆ² - ${message}`; 
            finalScoreDisplay.textContent = score;
            showScreen(gameOverScreen);
            
            let countdownTime = 5;
            countdownDisplay.textContent = countdownTime;
            countdownIntervalId = setInterval(() => {
                countdownTime--;
                countdownDisplay.textContent = countdownTime;
                if (countdownTime <= 0) {
                    clearInterval(countdownIntervalId);
                    showScreen(startScreen); 
                }
            }, 1000);
        }

        // çµ±ä¸€è™•ç†æ–¹å‘è®Šæ›´çš„å‡½æ•¸
        function handleDirectionChange(key) {
            if (!gameScreen.classList.contains('active') || isMoving) return;

            let newDirection = { x: direction.x, y: direction.y };
            
            switch (key) {
                case 'ArrowUp':
                case 'w':
                    if (direction.y === 0) newDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                    if (direction.y === 0) newDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                    if (direction.x === 0) newDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                    if (direction.x === 0) newDirection = { x: 1, y: 0 };
                    break;
                default:
                    return;
            }
            
            direction = newDirection;
        }

        // --- äº‹ä»¶ç›£è½å™¨ ---

        // 1. é–‹å§‹æŒ‰éˆ•
        startGameButton.addEventListener('click', () => {
            if (playerNameInput.value.trim() === '') {
                alert('è«‹è¼¸å…¥éŠç©åç¨±ï¼');
                return;
            }
            startGame();
        });

        // 2. å¾©æ´»æŒ‰éˆ• (ä¿®æ­£é»ï¼šé‡æ–°ç”Ÿæˆéšœç¤™ç‰©)
        reviveButton.addEventListener('click', () => {
            if (countdownIntervalId) clearInterval(countdownIntervalId);
            
            // é‡è¨­è›‡çš„ä½ç½® (å‡è¨­è›‡è®ŠçŸ­äº†)
            snake = [
                { x: 3, y: 1 },
                { x: 2, y: 1 },
                { x: 1, y: 1 }
            ];
            direction = { x: 1, y: 0 }; 
            
            // *** é—œéµä¿®æ­£ï¼šé‡æ–°ç”Ÿæˆéšœç¤™ç‰©å’Œé£Ÿç‰© ***
            generateObstacles(); 
            foods = [];
            generateFoods();

            showScreen(gameScreen);
            gameIntervalId = setInterval(updateGame, gameSpeed);
        });
        
        // 3. é‡æ–°é–‹å§‹æŒ‰éˆ•
        restartButton.addEventListener('click', () => {
            if (countdownIntervalId) clearInterval(countdownIntervalId);
            showScreen(startScreen);
        });


        // 4. éµç›¤æ§åˆ¶ (é˜²æ­¢è¼¸å…¥å¹²æ“¾)
        document.addEventListener('keydown', (event) => {
            if (gameScreen.classList.contains('active')) {
                const key = event.key.toLowerCase();
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
                    handleDirectionChange(event.key);
                    event.preventDefault(); 
                }
            } else if (event.target === playerNameInput) {
                return; 
            } else {
                return;
            }
        });
        
        // 5. è§¸æ§æ§åˆ¶ (ç•«å¸ƒå€åŸŸ)
        touchOverlay.addEventListener('touchstart', (event) => {
            event.preventDefault(); 
            if (gameScreen.classList.contains('active')) {
                const rect = touchOverlay.getBoundingClientRect();
                const touchX = event.touches[0].clientX - rect.left;
                const touchY = event.touches[0].clientY - rect.top;
                const width = rect.width;
                const height = rect.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const diffX = touchX - centerX;
                const diffY = touchY - centerY;
                
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX < 0) {
                        handleDirectionChange('ArrowLeft');
                    } else {
                        handleDirectionChange('ArrowRight');
                    }
                } else {
                    if (diffY < 0) {
                        handleDirectionChange('ArrowUp');
                    } else {
                        handleDirectionChange('ArrowDown');
                    }
                }
            }
        });
        
        // 6. è™›æ“¬æ–¹å‘éµæ§åˆ¶
        dpadUp.addEventListener('click', () => handleDirectionChange('ArrowUp'));
        dpadDown.addEventListener('click', () => handleDirectionChange('ArrowDown'));
        dpadLeft.addEventListener('click', () => handleDirectionChange('ArrowLeft'));
        dpadRight.addEventListener('click', () => handleDirectionChange('ArrowRight'));
        
        // 7. é¡¯å¼è™•ç†è¼¸å…¥æ¡†çš„ç„¦é»
        playerNameInput.addEventListener('click', () => {
            playerNameInput.focus();
        });
        playerNameInput.addEventListener('touchstart', () => {
            playerNameInput.focus();
        });


        // --- åˆå§‹ç‹€æ…‹ï¼šé¡¯ç¤ºé–‹å§‹ç•«é¢ä¸¦æª¢æŸ¥ä¸Šæ¬¡åˆ†æ•¸ ---
        showScreen(startScreen);
        // --- JavaScript å…§å®¹çµæŸ ---
    </script>
</body>
</html>
