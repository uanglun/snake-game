<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>è²ªåƒè›‡éŠæˆ²</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* --- CSS å…§å®¹é–‹å§‹ (åŒ…å«æ‰‹æ©Ÿæ ¼å¼èª¿æ•´) --- */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f4f4f4;
            /* é˜²æ­¢ç€è¦½å™¨åœ¨è§¸æ§æ™‚æ‹‰ä¼¸æˆ–ç¸®æ”¾é é¢ */
            touch-action: none; 
        }

        .screen {
            background-color: white;
            padding: 20px; /* æ‰‹æ©Ÿä¸Šæ¸›å°‘ padding */
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            display: none; 
            width: 90%; /* éŸ¿æ‡‰å¼å¯¬åº¦ */
            max-width: 460px; /* é™åˆ¶æœ€å¤§å¯¬åº¦ */
        }

        .screen.active {
            display: block; 
        }

        /* é–‹ç™¼è€…è³‡è¨Šæ¨£å¼ */
        .developer-info {
            font-size: 12px;
            color: #666;
            margin-top: -10px;
            margin-bottom: 20px;
        }

        /* éŠæˆ²ç•«å¸ƒå®¹å™¨ */
        #gameContainer {
            position: relative;
            /* åˆå§‹å°ºå¯¸èˆ‡ Canvas ç›¸åŒ */
            width: 400px; 
            height: 400px; 
            margin: 0 auto;
        }

        #gameCanvas {
            border: 5px solid #333;
            background-color: #eee;
            display: block;
        }
        
        /* éŸ¿æ‡‰å¼èª¿æ•´ï¼šç¢ºä¿å®¹å™¨åœ¨å°è¢å¹•ä¸Šå¯ä»¥å¡«æ»¿ */
        @media screen and (max-width: 480px) {
            #gameContainer {
                width: calc(100vw - 40px); 
                height: calc(100vw - 40px); 
                max-width: 400px;
                max-height: 400px;
            }
        }

        #infoBar {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            font-weight: bold;
            font-size: 0.9em; /* æ‰‹æ©Ÿä¸Šå­—é«”å°ä¸€é» */
        }
        
        /* æœ¬å±€æˆç¸¾çš„å€å¡Šæ¨£å¼ */
        #currentScoreRecord {
            margin-top: 15px;
            padding: 10px;
            border: 1px dashed #333;
            background-color: #ffe0b2; 
            font-weight: bold;
            display: none; 
        }

        button {
            padding: 10px 15px; /* æ‰‹æ©Ÿä¸ŠæŒ‰éˆ•å°ä¸€é» */
            margin: 8px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }

        /* éŠæˆ²çµæŸç•«é¢çš„æ¨£å¼å¾®èª¿ */
        #gameOverScreen h2 {
            color: red;
        }

        /* --- è§¸æ§ç–ŠåŠ å±¤æ¨£å¼ --- */
        #touchOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background-color: transparent; 
            cursor: pointer;
        }
        /* --- CSS å…§å®¹çµæŸ --- */
    </style>
</head>
<body>

    <div id="startScreen" class="screen active">
        <h1>è²ªåƒè›‡éŠæˆ² ğŸ</h1>
        <p class="developer-info">å¸ƒæ´›å…‹åœ‹ç‹é–‹ç™¼</p>
        <label for="playerName">è«‹è¼¸å…¥éŠç©åç¨±ï¼š</label>
        <input type="text" id="playerName" placeholder="ç©å®¶åç¨±" required autocomplete="off">
        
        <br><br>

        <label for="difficulty">é¸æ“‡é›£åº¦ï¼š</label>
        <select id="difficulty">
            <option value="easy">æ˜“ (ç„¡éšœç¤™, æ…¢)</option>
            <option value="medium" selected>ä¸­ (å°‘é‡ç‰†, æ¨™æº–)</option>
            <option value="hard">é›£ (æ›´å¤šç‰†, å¿«)</option>
            <option value="extreme">æ¥µé›£ (æ¥µå¿«)</option>
        </select>

        <br><br>
        
        <button id="startGameButton">é–‹å§‹éŠæˆ²</button>
        
        <div id="currentScoreRecord">
            **ä¸Šå±€æˆç¸¾**ï¼š
            <span id="recordedScore">0</span> åˆ†
        </div>
    </div>

    <div id="gameScreen" class="screen">
        <div id="infoBar">
            <span>ç©å®¶ï¼š<span id="displayPlayerName"></span></span>
            <span>é›£åº¦ï¼š<span id="displayDifficulty"></span></span>
            <span>åˆ†æ•¸ï¼š<span id="score">0</span></span>
        </div>
        
        <div id="gameContainer">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            <div id="touchOverlay"></div>
        </div>
    </div>

    <div id="gameOverScreen" class="screen">
        <h2 id="gameOverMessage">è²ªåƒè›‡éŠæˆ² - çµæŸï¼</h2>
        <p>ä½ çš„åˆ†æ•¸æ˜¯ï¼š<span id="finalScore">0</span></p>
        <button id="reviveButton">å¾©æ´»</button>
        <button id="restartButton">å›åˆ°é¦–é </button> <p>è‹¥æ²’æœ‰å¾©æ´»ï¼Œ<span id="countdown">5</span> ç§’å¾Œè‡ªå‹•å›åˆ°é¦–é ...</p>
    </div>

    <script>
        // --- JavaScript å…§å®¹é–‹å§‹ (ä¿®æ­£è¼¸å…¥å•é¡Œ) ---

        // --- å…ƒç´ é¸æ“‡å™¨ ---
        const startScreen = document.getElementById('startScreen');
        const gameScreen = document.getElementById('gameScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startGameButton = document.getElementById('startGameButton');
        const reviveButton = document.getElementById('reviveButton');
        const restartButton = document.getElementById('restartButton'); // æ–°å¢é‡æ–°é–‹å§‹æŒ‰éˆ•
        const playerNameInput = document.getElementById('playerName');
        const difficultySelect = document.getElementById('difficulty');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const finalScoreDisplay = document.getElementById('finalScore');
        const countdownDisplay = document.getElementById('countdown');
        const recordedScoreDisplay = document.getElementById('recordedScore');
        const scoreRecordContainer = document.getElementById('currentScoreRecord');
        const gameContainer = document.getElementById('gameContainer');
        const touchOverlay = document.getElementById('touchOverlay'); 


        // --- éŠæˆ²è¨­å®šè®Šæ•¸ ---
        let playerName = '';
        let currentDifficulty = 'medium';
        let gameSpeed = 150; 
        const INITIAL_TILE_COUNT = 20; // åˆå§‹ç¶²æ ¼æ•¸ (20x20)
        const INITIAL_CANVAS_SIZE = 400; 
        let snake = [];
        let foods = []; 
        let obstacles = []; 
        let direction = { x: 1, y: 0 }; 
        let score = 0;
        let gameIntervalId;
        let countdownIntervalId;
        let isMoving = false; // ç¢ºä¿åœ¨ä¸€å€‹éŠæˆ²å¾ªç’°ä¸­åªè™•ç†ä¸€æ¬¡æ–¹å‘æ”¹è®Š

        // --- é›£åº¦è¨­å®š (é€Ÿåº¦å·²å„ªåŒ–ï¼Œæ›´éˆæ•) ---
        const difficultySettings = {
            easy: { speed: 180, label: 'æ˜“ (æ…¢)', obstacleCount: 0, maxFoods: 5 },        
            medium: { speed: 130, label: 'ä¸­ (æ¨™æº–)', obstacleCount: 8, maxFoods: 3 },     
            hard: { speed: 80, label: 'é›£ (å¿«)', obstacleCount: 16, maxFoods: 1 },        
            extreme: { speed: 50, label: 'æ¥µé›£ (æ¥µå¿«)', obstacleCount: 20, maxFoods: 1 }  
        };

        // --- æœ¬åœ°å„²å­˜éµå€¼ ---
        const SESSION_SCORE_KEY = 'SNAKE_CURRENT_SCORE';

        // --- éŸ¿æ‡‰å¼èª¿æ•´ Canvas å°ºå¯¸ ---
        function adjustCanvasSize() {
            if (gameScreen.classList.contains('active')) {
                const containerWidth = gameContainer.offsetWidth;
                
                const newTileSize = Math.floor(containerWidth / INITIAL_TILE_COUNT);
                const newCanvasSize = newTileSize * INITIAL_TILE_COUNT;

                if (newCanvasSize > 0) {
                    canvas.width = newCanvasSize;
                    canvas.height = newCanvasSize;
                    gameContainer.style.width = newCanvasSize + 'px';
                    gameContainer.style.height = newCanvasSize + 'px';
                    
                    if (gameIntervalId) draw(); 
                }
            }
        }
        window.addEventListener('resize', adjustCanvasSize);

        // --- ç•«é¢åˆ‡æ›å‡½æ•¸ ---
        function showScreen(screen) {
            [startScreen, gameScreen, gameOverScreen].forEach(s => {
                s.classList.remove('active');
            });
            screen.classList.add('active');
            
            if (screen === startScreen) {
                loadSessionScore();
                // æ¢å¾©åˆå§‹ Canvas å°ºå¯¸
                canvas.width = INITIAL_CANVAS_SIZE;
                canvas.height = INITIAL_CANVAS_SIZE;
                gameContainer.style.width = INITIAL_CANVAS_SIZE + 'px';
                gameContainer.style.height = INITIAL_CANVAS_SIZE + 'px';
            } else if (screen === gameScreen) {
                adjustCanvasSize(); // é€²å…¥éŠæˆ²æ™‚èª¿æ•´å°ºå¯¸
            } else {
                scoreRecordContainer.style.display = 'none';
            }
        }

        // --- è®€å–/å„²å­˜æœ¬å±€æˆç¸¾ (SessionStorage) ---
        function loadSessionScore() {
            const lastScore = sessionStorage.getItem(SESSION_SCORE_KEY);
            if (lastScore && !isNaN(parseInt(lastScore))) {
                recordedScoreDisplay.textContent = parseInt(lastScore);
                scoreRecordContainer.style.display = 'block';
            } else {
                scoreRecordContainer.style.display = 'none';
            }
        }
        function saveSessionScore(currentScore) {
            sessionStorage.setItem(SESSION_SCORE_KEY, currentScore.toString());
        }

        // --- æª¢æŸ¥ä½ç½®æ˜¯å¦è¢«ä½”ç”¨ ---
        function isPositionOccupied(x, y) {
            if (snake.some(segment => segment.x === x && segment.y === y)) return true;
            if (obstacles.some(obs => obs.x === x && obs.y === y)) return true;
            if (foods.some(f => f.x === x && f.y === y)) return true;
            return false;
        }

        // --- éšœç¤™ç‰©ç”Ÿæˆå‡½æ•¸ ---
        function generateObstacles() {
            obstacles = [];
            const count = difficultySettings[currentDifficulty].obstacleCount;
            const boundaryX = INITIAL_TILE_COUNT;
            const boundaryY = INITIAL_TILE_COUNT;

            for (let i = 0; i < count; i++) {
                let newObstacle;
                let attempts = 0;
                
                do {
                    newObstacle = {
                        x: Math.floor(Math.random() * boundaryX),
                        y: Math.floor(Math.random() * boundaryY)
                    };
                    attempts++;
                } while (isPositionOccupied(newObstacle.x, newObstacle.y) && attempts < 100); 
                
                if (attempts < 100) {
                    obstacles.push(newObstacle);
                }
            }
        }

        // --- é£Ÿç‰©ç”Ÿæˆå‡½æ•¸ ---
        function generateFoods() {
            const maxFoods = difficultySettings[currentDifficulty].maxFoods;
            const boundaryX = INITIAL_TILE_COUNT;
            const boundaryY = INITIAL_TILE_COUNT;

            while (foods.length < maxFoods) {
                let newFood;
                let attempts = 0;

                do {
                    newFood = {
                        x: Math.floor(Math.random() * boundaryX),
                        y: Math.floor(Math.random() * boundaryY)
                    };
                    attempts++;
                } while (isPositionOccupied(newFood.x, newFood.y) && attempts < 100); 
                
                if (attempts < 100) {
                    foods.push(newFood);
                }
            }
        }

        // --- éŠæˆ²åˆå§‹åŒ–å‡½æ•¸ ---
        function initializeGame() {
            gameSpeed = difficultySettings[currentDifficulty].speed;
            
            snake = [
                { x: 3, y: 1 },
                { x: 2, y: 1 },
                { x: 1, y: 1 }
            ];
            direction = { x: 1, y: 0 }; 
            score = 0;
            foods = []; 
            scoreDisplay.textContent = score;
            isMoving = false; 
            
            ctx.fillStyle = '#eee';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            generateObstacles(); 
            generateFoods(); 
            draw();
        }

        // --- ç¹ªè£½å‡½æ•¸ ---
        function draw() {
            const currentTileSize = canvas.width / INITIAL_TILE_COUNT; 

            ctx.fillStyle = '#eee';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 1. ç¹ªè£½é£Ÿç‰©
            ctx.fillStyle = 'red';
            foods.forEach(food => {
                ctx.fillRect(food.x * currentTileSize, food.y * currentTileSize, currentTileSize, currentTileSize);
            });

            // 2. ç¹ªè£½éšœç¤™ç‰©
            ctx.fillStyle = '#666'; 
            obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x * currentTileSize, obstacle.y * currentTileSize, currentTileSize, currentTileSize);
            });

            // 3. ç¹ªè£½è›‡ 
            snake.forEach((segment, index) => {
                ctx.fillStyle = (index === 0) ? '#006400' : 'black'; 
                ctx.fillRect(segment.x * currentTileSize, segment.y * currentTileSize, currentTileSize, currentTileSize);
                
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(segment.x * currentTileSize, segment.y * currentTileSize, currentTileSize, currentTileSize);
            });
        }

        // --- éŠæˆ²é‚è¼¯ä¸»å¾ªç’° ---
        function updateGame() {
            isMoving = true; 

            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            const boundaryX = INITIAL_TILE_COUNT;
            const boundaryY = INITIAL_TILE_COUNT;

            const hitWall = head.x < 0 || head.x >= boundaryX || head.y < 0 || head.y >= boundaryY;
            const hitObstacle = obstacles.some(obs => obs.x === head.x && obs.y === head.y);

            if (hitWall || hitObstacle) {
                clearInterval(gameIntervalId);
                saveSessionScore(score); 
                showGameOver(hitWall ? 'ä½ æ’åˆ°ç‰†äº†ï¼' : 'ä½ æ’åˆ°éšœç¤™ç‰©äº†ï¼');
                return; 
            }

            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    clearInterval(gameIntervalId);
                    saveSessionScore(score); 
                    showGameOver('ä½ å’¬åˆ°è‡ªå·±äº†ï¼'); 
                    return;
                }
            }

            snake.unshift(head); 
            let eaten = false;

            const foodIndex = foods.findIndex(f => f.x === head.x && f.y === head.y);

            if (foodIndex !== -1) {
                score += 10;
                scoreDisplay.textContent = score;
                foods.splice(foodIndex, 1); 
                generateFoods(); 
                eaten = true;
            } 

            if (!eaten) {
                snake.pop(); 
            }

            draw();
            isMoving = false; 
        }

        // --- å•Ÿå‹•éŠæˆ²å‡½æ•¸ ---
        function startGame() {
            playerName = playerNameInput.value || 'åŒ¿åç©å®¶'; 
            currentDifficulty = difficultySelect.value;

            document.getElementById('displayPlayerName').textContent = playerName;
            document.getElementById('displayDifficulty').textContent = difficultySettings[currentDifficulty].label;

            if (gameIntervalId) clearInterval(gameIntervalId);
            
            initializeGame();
            showScreen(gameScreen);

            gameIntervalId = setInterval(updateGame, gameSpeed);
        }

        // --- å¾©æ´»/éŠæˆ²çµæŸè™•ç† ---
        function showGameOver(message) {
            if (gameIntervalId) clearInterval(gameIntervalId);
            if (countdownIntervalId) clearInterval(countdownIntervalId);

            document.getElementById('gameOverMessage').textContent = `è²ªåƒè›‡éŠæˆ² - ${message}`; 
            finalScoreDisplay.textContent = score;
            showScreen(gameOverScreen);
            
            let countdownTime = 5;
            countdownDisplay.textContent = countdownTime;
            countdownIntervalId = setInterval(() => {
                countdownTime--;
                countdownDisplay.textContent = countdownTime;
                if (countdownTime <= 0) {
                    clearInterval(countdownIntervalId);
                    showScreen(startScreen); 
                }
            }, 1000);
        }

        // çµ±ä¸€è™•ç†æ–¹å‘è®Šæ›´çš„å‡½æ•¸
        function handleDirectionChange(key) {
            // éŠæˆ²æœªé–‹å§‹æˆ–æ­£åœ¨è™•ç†å‰ä¸€æ ¼ç§»å‹•æ™‚ï¼Œå¿½ç•¥è¼¸å…¥
            if (!gameScreen.classList.contains('active') || isMoving) return;

            let newDirection = { x: direction.x, y: direction.y };
            
            switch (key) {
                case 'ArrowUp':
                case 'w':
                    if (direction.y === 0) newDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                    if (direction.y === 0) newDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                    if (direction.x === 0) newDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                    if (direction.x === 0) newDirection = { x: 1, y: 0 };
                    break;
                default:
                    return;
            }
            
            direction = newDirection;
        }

        // --- äº‹ä»¶ç›£è½å™¨ ---

        // 1. é–‹å§‹éŠæˆ²æŒ‰éˆ•
        startGameButton.addEventListener('click', () => {
            if (playerNameInput.value.trim() === '') {
                alert('è«‹è¼¸å…¥éŠç©åç¨±ï¼');
                return;
            }
            startGame();
        });

        // 2. å¾©æ´»æŒ‰éˆ•
        reviveButton.addEventListener('click', () => {
            if (countdownIntervalId) clearInterval(countdownIntervalId);
            
            if (snake.length > 3) {
                snake.pop(); 
                snake.pop(); 
            }
            
            snake = [
                { x: 3, y: 1 },
                { x: 2, y: 1 },
                { x: 1, y: 1 }
            ];
            direction = { x: 1, y: 0 }; 
            
            foods = [];
            generateFoods();

            showScreen(gameScreen);
            gameIntervalId = setInterval(updateGame, gameSpeed);
        });
        
        // 3. é‡æ–°é–‹å§‹æŒ‰éˆ• (æ–°å¢)
        restartButton.addEventListener('click', () => {
            if (countdownIntervalId) clearInterval(countdownIntervalId);
            showScreen(startScreen);
        });


        // 4. éµç›¤æ§åˆ¶ (æ¡Œé¢ç«¯) - ä¿®æ­£ï¼šé¿å…é˜»æ­¢è¼¸å…¥æ¡†çš„é è¨­è¡Œç‚º
        document.addEventListener('keydown', (event) => {
            // åªæœ‰ç•¶éŠæˆ²ç•«é¢åœ¨æ´»å‹•ç‹€æ…‹ *ä¸”* ç„¦é»ä¸åœ¨è¼¸å…¥æ¡†æ™‚ï¼Œæ‰è™•ç†æ–¹å‘éµ
            if (gameScreen.classList.contains('active')) {
                const key = event.key.toLowerCase();
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
                    handleDirectionChange(event.key);
                    event.preventDefault(); // é˜»æ­¢é é¢æ»¾å‹•
                }
            } else if (event.target === playerNameInput) {
                // å¦‚æœç„¦é»åœ¨è¼¸å…¥æ¡†ï¼Œä¸åŸ·è¡Œä»»ä½•é˜»æ­¢è¼¸å…¥çš„å‹•ä½œ
                return; 
            } else {
                 // å…¶ä»–æƒ…æ³ä¸‹çš„æŒ‰éµï¼ˆä¾‹å¦‚åœ¨é–‹å§‹ç•«é¢æŒ‰æ–¹å‘éµï¼‰
                return;
            }
        });
        
        // 5. è§¸æ§æ§åˆ¶ (æ‰‹æ©Ÿç«¯)
        touchOverlay.addEventListener('touchstart', (event) => {
            event.preventDefault(); // é˜²æ­¢æ»¾å‹•
            
            if (gameScreen.classList.contains('active')) {
                const rect = touchOverlay.getBoundingClientRect();
                const touchX = event.touches[0].clientX - rect.left;
                const touchY = event.touches[0].clientY - rect.top;
                
                const width = rect.width;
                const height = rect.height;
                
                const centerX = width / 2;
                const centerY = height / 2;
                
                const diffX = touchX - centerX;
                const diffY = touchY - centerY;
                
                // æ ¸å¿ƒé‚è¼¯ï¼šåˆ¤æ–·æ˜¯æ©«å‘ç§»å‹•å¤šé‚„æ˜¯ç¸±å‘ç§»å‹•å¤š
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX < 0) {
                        handleDirectionChange('ArrowLeft');
                    } else {
                        handleDirectionChange('ArrowRight');
                    }
                } else {
                    if (diffY < 0) {
                        handleDirectionChange('ArrowUp');
                    } else {
                        handleDirectionChange('ArrowDown');
                    }
                }
            }
        });
        
        // 6. é¡¯å¼è™•ç†è¼¸å…¥æ¡†çš„ç„¦é»ï¼ˆç¢ºä¿åœ¨é»æ“Šæ™‚éµç›¤æœƒå½ˆå‡ºï¼‰
        playerNameInput.addEventListener('click', () => {
            playerNameInput.focus();
        });
        playerNameInput.addEventListener('touchstart', () => {
            playerNameInput.focus();
        });


        // --- åˆå§‹ç‹€æ…‹ï¼šé¡¯ç¤ºé–‹å§‹ç•«é¢ä¸¦æª¢æŸ¥ä¸Šæ¬¡åˆ†æ•¸ ---
        showScreen(startScreen);
        // --- JavaScript å…§å®¹çµæŸ ---
    </script>
</body>
</html>